#!/usr/bin/env python3

import sys
import os
import argparse
import shlex
import shutil
import subprocess
import time

__version__ = '0.4'

DEFAULT_USER = 'clig'

class Clig:
    def __init__(self):
        # Top-level argument parser
        parser = argparse.ArgumentParser()

        # Sub-parser for commands
        subparsers = parser.add_subparsers(dest='command', help='available commands')

        # Global options
        parser.add_argument('--remote', '-r', help='Remote host')
        parser.add_argument('--user', '-u', default=DEFAULT_USER, help='Remote user')
        parser.add_argument('--version', '-v', action='store_true', help='Print version')

        # Git
        subparser = subparsers.add_parser('git')

        # Create
        subparser = subparsers.add_parser('create')
        subparser.add_argument('name')
        subparser.add_argument('host', nargs='?', default=None)

        # List
        subparser = subparsers.add_parser('list')
        subparser.add_argument('--remote', action='store_true')

        # Clone
        subparser = subparsers.add_parser('clone')
        subparser.add_argument('host')

        # Backup
        subparser = subparsers.add_parser('backup')
        subparser.add_argument('host')

        # Update
        subparser = subparsers.add_parser('update')

        self.args,self.var = parser.parse_known_args()
        if self.args.version:
            print(__version__)
            return

        if not self.args.command:
            self.args.command = 'default'

        fn_command = getattr(self, '_cmd_'+self.args.command)
        fn_command()

    def _call(self, command_line, *args, **kwds):
        if 'stdout' not in kwds:
            kwds['stdout'] = subprocess.PIPE
            kwds['stderr'] = subprocess.STDOUT

        process = subprocess.Popen(
            shlex.split(command_line % args),
            **kwds
            )
        out,err = process.communicate()
        if out is not None:
            return out

    def _cmd_git(self):
        base = os.path.abspath('.')
        #fmt = ' %%-%ds' % (shutil.get_terminal_size().columns - 1)
        fmt = '-' * (shutil.get_terminal_size().columns)# - 1)
        for root,directories,filenames in os.walk(base):
            if '.git' not in directories:
                continue
            name = root[len(base)+1:]
            if name:
                sys.stdout.write('\x1b[34m')
                sys.stdout.write(fmt + '\r--- ')
                sys.stdout.write('\x1b[1;35m')
                sys.stdout.write(name)
                sys.stdout.write(' \x1b[0m\n')
            os.chdir(root)
            #print('git', root, self.var)
            self._call('git %s', ' '.join(self.var), stdout=None, stderr=None)
        return

    def _cmd_default(self):
        self.var = ['status', '-s']
        self._cmd_git()
        return

    def _cmd_create(self):
        if self.args.host:
            print(' '.join(sys.argv[1:-1]))
            self._call('ssh %s@%s clig %s',
                self.args.user,
                self.args.host,
                ' '.join(sys.argv[1:-1]),
                )
        else:
            dirname,gitname = os.path.split(self.args.name)
            current_dir = os.getcwd()
            if dirname:
                os.makedirs(dirname, mode=0o755, exist_ok=True)
                os.chdir(dirname)
            if not gitname.endswith('.git'):
                gitname = gitname + '.git'
            if not os.path.isdir(gitname):
                self._call('git init --bare %s', gitname)
            os.chdir(current_dir)
        return

    def _cmd_list(self):
        base = os.path.abspath('.')
        for root,directories,filenames in os.walk(base):
            for directory in directories:
                if self.args.remote:
                    print('????')
                    if not directory.endswith('.git'):
                        continue
                else:
                    if '.git' not in directories:
                        continue
                name = os.path.join(root, directory)
                name = name[len(base)+1:]
                print(name)
        return

    def _cmd_clone(self):
        out = self._call('ssh %s@%s clig list',
            self.args.user,
            self.args.host,
            )
        repos = out.decode('utf-8').strip().split('\n')
        current_dir = os.getcwd()
        for repo in repos:
            dirname, gitname = os.path.split(repo)
            if dirname:
                os.makedirs(dirname, mode=0o755, exist_ok=True)
                os.chdir(dirname)
            check = gitname
            if check.endswith('.git'):
                check = check[:-4]
            sys.stdout.write('\033[32m' + os.path.join(dirname, gitname) + '\033[0m\n')
            if not os.path.isdir(check):
                out = self._call('git clone %s@%s:%s',
                    self.args.user,
                    self.args.host,
                    os.path.join(dirname, gitname),
                    )
                sys.stdout.buffer.write(out)
            os.chdir(current_dir)
        return

    def _cmd_backup(self):
        out = self._call('ssh %s@%s clig list --remote',
            self.args.user,
            self.args.host,
            )
        out = out.decode('utf-8').strip().split('\n')
        sys.stdout.write('\033[32mBacking up '+str(len(out))+' repositories\033[0m\n')
        paths = ' '.join(out)
        tar = self._call('ssh %s@%s tar zcpf - %s',
            self.args.user,
            self.args.host,
            paths,
            )
        path = 'git-%s-%s.tar.gz' % (self.args.host, time.strftime('%Y-%m-%d_%H%M%S'))
        with open(path, 'wb') as fp:
            fp.write(tar)
        return


if '__main__' == __name__:
    Clig()
